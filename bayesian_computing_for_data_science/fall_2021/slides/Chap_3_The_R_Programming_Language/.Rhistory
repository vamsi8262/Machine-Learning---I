asqplusb( a=2 , b=1 )
asqplusb( a=2 )  # b gets default value
asqplusb( b=1 )  # error: a has no default value
asqplusb( 2 )    # value is assigned to first argument
####################################################################
# Conditions and loops
?"Control"
x = 5
if ( x <= 3 ) {  # if x is less than or equal to 3
show("small")  # display the word "small"
} else {         # otherwise
show("big")    # display the word "big"
}
?"plot"
??"plot"
?"?"
?plot
help(plot)
??
?
"?"
?"?"
help(plot)
?"?"
help(plot)
??plot
??"plot"
0.5 - 0.3 == 0.3 - 0.1
c(1, 2)
c(1,2,3) * c(7,6,5)
x = c( 2.718 , 3.14 , 1.414 , 47405 )             # define the vector
x[0]
x[1]
x[c(1, 2)]
?factor
x = c( "high" , "medium" , "low" , "high" , "medium" )
xf = factor( x )
xf
as.numeric(xf)
xfol = factor( x , levels=c("low","medium","high") , ordered=TRUE ,
labels=c("Bottom SES","Middle SES","Top SES") )
xfol
a = array( 1:24 , dim=c(3,4,2) , # 3 rows, 4 columns, 2 layers
dimnames = list( RowDimName = c("R1","R2","R3") ,
ColDimName = c("C1","C2","C3","C4") ,
LayDimName = c("L1","L2") ) )
a
a[,3,2]
a["R3",,"L2"]
a[3, , 2]
d = data.frame( Integers=1:3 , NumberNames=c("one","two","three") )
d[[2]]          # the second element contents
d[,2]
setwd("~/Dropbox/work/teaching/gwu/bayesian_methods_for_data_science/lectures/slides/Chap_3_The_R_Programming_Language")
a
asqplusb = function( a , b=1 ) {  # begin function definition
c = a^2 + b
return( c )
}  # end of function definition
?proc.time()
source("DBDA2E-utilities.R")             # read defn. of openGraph, saveGraph
openGraph( width=3 , height=4 )          # open a graphics window
saveGraph( file="temp" , type="pdf" )    # save the graph as "temp.pdf"
source("DBDA2E-utilities.R")             # read defn. of openGraph, saveGraph
openGraph( width=3 , height=4 )          # open a graphics window
saveGraph( file="temp" , type="pdf" )    # save the graph as "temp.pdf"
source("DBDA2E-utilities.R")             # read defn. of openGraph, saveGraph
openGraph( width=3 , height=4 )          # open a graphics window
saveGraph( file="temp" , type="pdf" )    # save the graph as "temp.pdf"
clear()
clear
source("DBDA2E-utilities.R")             # read defn. of openGraph, saveGraph
install.rjags
install.packages(rjags)
install.packages(parallel)
?rjags
install.packages("rjags")
source("DBDA2E-utilities.R")             # read defn. of openGraph, saveGraph
openGraph( width=3 , height=4 )          # open a graphics window
saveGraph( file="temp" , type="pdf" )    # save the graph as "temp.pdf"
source("DBDA2E-utilities.R")             # read defn. of openGraph, saveGraph
install.packages("rjags")
source("DBDA2E-utilities.R")             # read defn. of openGraph, saveGraph
openGraph( width=3 , height=4 )          # open a graphics window
saveGraph( file="temp" , type="pdf" )    # save the graph as "temp.pdf"
openGraph( width=3 , height=4 )          # open a graphics window
saveGraph( file="temp" , type="pdf" )    # save the graph as "temp.pdf"
?read.csv
?data.frame
require(stats) # for lowess, rpois, rnorm
plot(cars)
lines(lowess(cars))
?write.csv
source('~/Dropbox/work/teaching/gwu/bayesian_methods_for_data_science/lectures/slides/Chap_3_The_R_Programming_Language/Driver.R')
source('~/Dropbox/work/teaching/gwu/bayesian_methods_for_data_science/lectures/slides/Chap_3_The_R_Programming_Language/Driver.R')
source('~/Dropbox/work/teaching/gwu/bayesian_methods_for_data_science/lectures/slides/Chap_3_The_R_Programming_Language/Driver.R')
loadData(trainingSet, "cnt", "temp")
loadData(trainingSet, "cnt", "temp")
data = read.csv(datasetName)
c(cnt, temp) = loadData(trainingSet, "cnt", "temp")
data = read.csv(datasetName)
trainingSet = "hour.csv"
data = read.csv(trainingSet)
data
y = data$"cnt"
y
y = data$"temp"
y
list(cnt, temp) = loadData(trainingSet, "cnt", "temp")
data = loadData(trainingSet, "cnt", "temp")
data
data = loadData(trainingSet, "cnt", "temp")
data
data[0]
debugSource('~/Dropbox/work/teaching/gwu/bayesian_methods_for_data_science/lectures/slides/Chap_3_The_R_Programming_Language/Solution.R')
data = loadData(trainingSet, "cnt", "temp")
data = loadData(trainingSet, "cnt", "temp")
data
data = loadData(trainingSet, "cnt", "temp")
y
x
data
data$yName
data$"cnt"
yName
y
data$yName
yName == "cnt"
data$yName == data$"cnt"
colnames( data )
data = loadData(trainingSet, "cnt", "temp")
data = loadData(trainingSet, "cnt", "temp")
data
source('~/Dropbox/work/teaching/gwu/bayesian_methods_for_data_science/lectures/slides/Chap_3_The_R_Programming_Language/Solution.R')
data = loadData(trainingSet, "cnt", "temp")
data
c(b0, b1) = train(cnt, temp)
cnt
c(b0, b1) = train(cnt, temp)
cnt
data[0]
data
data[0]
data[1]
c(b0, b1) = train(cnt, temp)
c(b0, b1) = train(cnt, temp)
cnt
temp
data[1]
data[2]
cnt
data
c(b0, b1) = train(cnt, temp)
cnt
cnt = data[[1]]
cnt
list(cnt, temp) = loadData(trainingSet, "cnt", "temp")
c(cnt, temp) = loadData(trainingSet, "cnt", "temp")
c(b0, b1) = train(cnt, temp)
c(b0, b1) = train(cnt, temp)
b = train(cnt, temp)
cnt, temp
b = train(cnt, temp)
x
y
cnt
cnt[1]
cnt[[1]]
source('~/Dropbox/work/teaching/gwu/bayesian_methods_for_data_science/lectures/slides/Chap_3_The_R_Programming_Language/Solution.R')
b = train(cnt, temp)
temp = dataOfCntTemp[[2]]
temp = dataOfCntTemp[[2]]
dataOfCntTemp = loadData(trainingSet, "cnt", "temp")
dataOfCntTemp
cnt = dataOfCntTemp[[1]]
cnt
cnt[[1]]
temp = dataOfCntTemp[[2]]
b = train(cnt, temp)
b
plotDataModel(cnt, temp, b1, b0, trainingResultFig)
source("Solution.R")
# Training set
trainingSet = "hour.csv"
# Testing set
testingSet = "day.csv"
# Training result figure
trainingResultFig = "trainingResultFig.pdf"
# Testing result figure
testingResultFig = "testingResultFig.pdf"
# mse file
mseFile = "mse.txt";
# Load data from trainning set
dataOfCntTemp = loadData(trainingSet, "cnt", "temp")
cnt = dataOfCntTemp[[1]]
temp = dataOfCntTemp[[2]]
# Train the linear model on training data
b = train(cnt, temp)
b0 = b[[0]]
b1 = b[[1]]
# Plot the data and linear model
plotDataModel(cnt, temp, b1, b0, trainingResultFig)
# Load data from testing set
c(cnt, temp) = loadData(testingSet, "cnt", "temp")
source('~/Dropbox/work/teaching/gwu/bayesian_methods_for_data_science/lectures/slides/Chap_3_The_R_Programming_Language/Driver.R')
source('~/Dropbox/work/teaching/gwu/bayesian_methods_for_data_science/lectures/slides/Chap_3_The_R_Programming_Language/Driver.R')
source('~/Dropbox/work/teaching/gwu/bayesian_methods_for_data_science/lectures/slides/Chap_3_The_R_Programming_Language/SimpleGraph.R')
source('~/Dropbox/work/teaching/gwu/bayesian_methods_for_data_science/lectures/slides/Chap_3_The_R_Programming_Language/SimpleGraph.R')
source('~/Dropbox/work/teaching/gwu/bayesian_methods_for_data_science/lectures/slides/Chap_3_The_R_Programming_Language/SimpleGraph.R')
source('~/Dropbox/work/teaching/gwu/bayesian_methods_for_data_science/lectures/slides/Chap_3_The_R_Programming_Language/SimpleGraph.R')
source('~/Dropbox/work/teaching/gwu/bayesian_methods_for_data_science/lectures/slides/Chap_3_The_R_Programming_Language/SimpleGraph.R')
source('~/Dropbox/work/teaching/gwu/bayesian_methods_for_data_science/lectures/slides/Chap_3_The_R_Programming_Language/SimpleGraph.R')
source('~/Dropbox/work/teaching/gwu/bayesian_methods_for_data_science/lectures/slides/Chap_3_The_R_Programming_Language/SimpleGraph.R')
source('~/Dropbox/work/teaching/gwu/bayesian_methods_for_data_science/lectures/slides/Chap_3_The_R_Programming_Language/SimpleGraph.R')
source('~/Dropbox/work/teaching/gwu/bayesian_methods_for_data_science/lectures/slides/Chap_3_The_R_Programming_Language/SimpleGraph.R')
?plot
help.start()
?plot
??plot
0.5 == 0.5
all.equal(0.5 − 0.3, 0.3 − 0.1)
all.equal(0.5 - 0.3, 0.3 - 0.1)
all.equal(0.5 - 0.3, 0.3 - 0.2)
if (all.equal(0.5 - 0.3, 0.3 - 0.2)) {}
c(1,2,3) * c(7,6,5)
2 * c(1,2,3)
2 + c(1,2,3)
2+3:6      # colon operator has precedence over addition
?:
?":"
1:5
seq( from=0 , to=3 , by=0.5001 )       # will not exceed end value
seq( from=0 , by=0.5 , length.out=7 )  # end not specified
seq( from=0 , to=3 , length.out=7 )    # increment not specified
seq( to=3 , by=0.5 , length.out=7 )    # start not specified
1+2*3^2       # power first, then multiplication, then addition
TRUE | TRUE & FALSE  # conjunction has precedence over disjunction
( TRUE | TRUE ) & FALSE  # parentheses force disjunction first
x <- 2  # assigns the value 2 to variable named x
x = 2   # assigns the value 2 to variable named x
x < - 2  # assigns the value 2 to variable named x
x
x == y   # although mathematically TRUE, it's FALSE for limited precision
x == y   # although mathematically TRUE, it's FALSE for limited precision
x = 0.5 - 0.3
y = 0.3 - 0.1
x == y
all.equal(x,y)  # equal up to precision of computer
if (all.equal(0.2, 0.3)) {}
all.equal(0.2, 0.3)
if (isTrue(all.equal(0.2, 0.3))) {}
if (isTRUE(all.equal(0.2, 0.3))) {}
?print
if (isTRUE(all.equal(0.2, 0.3))) {"TRUE"}
if (!isTRUE(all.equal(0.2, 0.3))) {"TRUE"}
?isTRUE
all.equal(x,y)  # equal up to precision of computer
isTRUE(all.equal(x,y))
c(1,2,3) * c(7,6,5)
2 * c(1,2,3)
2 + c(1,2,3)
c(1,2,3)
1:3
seq( from=0 , to=3 , by=0.5 )          # length not specified
seq( from=0 , to=3 , by=0.5001 )       # will not exceed end value
seq( from=0 , by=0.5 , length.out=7 )  # end not specified
seq( from=0 , to=3 , length.out=7 )    # increment not specified
rep( ABC, 2 )
ABC = c("A","B","C")  # define a vector for replication
rep( ABC, 2 )
rep( ABC, times=2 )
ABC
rep( ABC, times=c(4,2,1) )
rep( ABC, each=2 )
x = c( 2.718 , 3.14 , 1.414 , 47405 )             # define the vector
names(x) = c( "e" , "pi" , "sqrt2" , "zipcode" )
x
x[1]
x[[1]]
x = c( 2.718 , 3.14 , 1.414 , 47405 )             # define the vector
x
x[1]
x[[1]]
name(x[1])
x = c( 2.718 , 3.14 , 1.414 , 47405 )             # define the vector
names(x) = c( "e" , "pi" , "sqrt2" , "zipcode" )
x[1]
x[c(2,4)]                    # which indices to include
x[c(-1,-3)]                  # which indices to exclude
x[c(FALSE,TRUE,FALSE,TRUE)]  # for each position, include it?
x[c("pi","zipcode")]         # names of indices to include
x[[2,4]]
x = c( "high" , "medium" , "low" , "high" , "medium" )
x
xf = factor( x )
xf
as.numeric(xf)
nchar(1, type = "bytes")
nchar("high", type = "bytes")
nchar("highsdfsdfsdf", type = "bytes")
nchar(x, type = "bytes")
nchar(xf, type = "bytes")
xfo = factor( xf , levels=c("low","medium","high") , ordered=TRUE )
xfo
as.numeric(xfo)
xfol = factor( x , levels=c("low","medium","high") , ordered=TRUE ,
labels=c("Bottom SES","Middle SES","Top SES") )
xfol
xfo = factor( xf , levels=c("low","medium","high")  )
xfo
, ordered=TRUE
xfo = factor( xf , levels=c("low","medium","high") , ordered=TRUE )
xfo
xfol = factor( x ,
labels=c("Bottom SES","Middle SES","Top SES") )
xfol
as.numeric(xfo)
levels=c("low","medium","high") , ordered=TRUE ,
xfol = factor( x , levels=c("low","medium","high") , ordered=TRUE ,
labels=c("Bottom SES","Middle SES","Top SES") )
xfol
matrix( 1:6 , ncol=3 )  # contents are 1:6, filled by column
matrix( 1:6 , nrow=2 )  # or you can specify number of rows
matrix( 1:6 , nrow=2 )  # or you can specify number of rows
matrix( 1:6 , ncol=3 )  # contents are 1:6, filled by column
matrix( 1:6 , nrow=2 )  # or you can specify number of rows
matrix( 1:6 , nrow=2 , byrow=TRUE )  # filled by row instead of by column
matrix( 1:6 , nrow=2 ,       # with names of dimensions and rows and columns
dimnames=list( TheRowDimName=c("Row1Name","Row2Name") ,
TheColDimName=c("Col1Name","Col2Name","Col3Name") ) )
x = matrix( 1:6 , nrow=2 ,   # assign matrix to x
dimnames=list( TheRowDimName=c("Row1Name","Row2Name") ,
TheColDimName=c("Col1Name","Col2Name","Col3Name") ) )
x[2,3]  # use numerical indices
x["Row2Name","Col3Name"]  # use row, column names
x[2,1:3]  # specify range of columns for inclusion
x[2,]  # leave range of columns blank to include all columns
x[[,3]]  # all rows from column 3, returned as a vector
x[,3]  # all rows from column 3, returned as a vector
x[2,] # 2nd row (returned as vector)
x[2] # no comma; returns 2nd element.
a = array( 1:24 , dim=c(3,4,2) , # 3 rows, 4 columns, 2 layers
dimnames = list( RowDimName = c("R1","R2","R3") ,
ColDimName = c("C1","C2","C3","C4") ,
LayDimName = c("L1","L2") ) )
a
a["R3",,"L2"]  # returns all columns of R3 and L2, as a vector
MyList = list( "a"=1:3 , "b"=matrix(1:6,nrow=2) , "c"="Hello, world." )
MyList
MyList$a        # the contents of the list item named "a"
MyList$a[2]     # the second element of the list item named "a"
MyList[[1]]     # the contents of the first list item
MyList[1]
MyList[1]       # the first list item, including its name
MyList[1][2]    # does not make sense in this case
d = data.frame( Integers=1:3 , NumberNames=c("one","two","three") )
d
d$NumberNames   # notice this is a factor
d[[2]]          # the second element contents
d[2]            # the second element with its name
d[,2]           # elements can be accessed as if it's a matrix
d[2]            # the second element with its name
d[,2]           # elements can be accessed as if it's a matrix
d[2,]           # elements can be accessed as if it's a matrix
d[2]            # the second element with its name
d[[2]]          # the second element contents
d[2]            # the second element with its name
d[,2]           # elements can be accessed as if it's a matrix
d[2,]           # elements can be accessed as if it's a matrix
HGNdf = read.csv( "HGN.csv" )
HGNdf$Hair
as.numeric(HGNdf$Hair)
HGNdf$Hair = factor( HGNdf$Hair , levels=c("red","blond","brown","black") )
HGNdf$Hair
as.numeric(HGNdf$Hair)
HGNdf$Name
HGNdf$Name = as.vector( HGNdf$Name )
HGNdf$Name
HGNdf$Group
HGNdf$Group = factor( HGNdf$Group )
HGNdf$Group
?"write.csv"
write.csv( HGNdf , file="HGN.csv" , row.names=FALSE , quote=FALSE )
?"save"
save( HGNdf , file="HGN.Rdata" )
?"load"
load( "HGN.Rdata" )
?"objects"
objects()
x = c( rep(1,100) , rep(2,200) , rep(3,300) )  # 100 1's, 200 2's, 300 3's
summary(x)
xf = factor(x)
summary(xf)
asqplusb = function( a , b=1 ) {  # begin function definition
c = a^2 + b
return( c )
}  # end of function definition
asqplusb( a=3 , b=2 )
asqplusb( b=2 , a=3 )
asqplusb( 3 , 2 )
asqplusb( 2 , 3 )
asqplusb( a=2 , b=1 )
asqplusb( a=2 )  # b gets default value
asqplusb( b=1 )  # error: a has no default value
asqplusb( 2 )    # value is assigned to first argument
asqplusb( 2 )    # value is assigned to first argument
asqplusb = function( a = 1 , b ) {  # begin function definition
c = a^2 + b
return( c )
}  # end of function definition
asqplusb( 2 )    # value is assigned to first argument
asqplusb = function( a , b=1 ) {  # begin function definition
c = a^2 + b
return( c )
}  # end of function definition
asqplusb( 2 )    # value is assigned to first argument
x = 5
if ( x <= 3 ) {  # if x is less than or equal to 3
show("small")  # display the word "small"
} else {         # otherwise
show("big")    # display the word "big"
}
for ( countDown in 5:1 ) {
show(countDown)
}
for ( note in c("do","re","mi") ) {
show(note)
}
startTime = proc.time()
y = vector(mode="numeric",length=1.0E6)
for ( i in 1:1.0E6 ) { y[i] = log(i) }
stopTime = proc.time()
elapsedTime = stopTime - startTime
show(elapsedTime)
d = data.frame( Integers=1:3 , NumberNames=c("one","two","three") )
d
d$NumberNames   # notice this is a factor
d[[2]]          # the second element contents
d[2]            # the second element with its name
d[,2]           # elements can be accessed as if it's a matrix
d[2,]           # elements can be accessed as if it's a matrix
1:5
d[3,]           # elements can be accessed as if it's a matrix
d[4,]           # elements can be accessed as if it's a matrix
d[2,]           # elements can be accessed as if it's a matrix
d[,2]           # elements can be accessed as if it's a matrix
d[2,]           # elements can be accessed as if it's a matrix
d[,2]           # elements can be accessed as if it's a matrix
d[2]            # the second element with its name
d[2]            # the second element with its name
d[,2]           # elements can be accessed as if it's a matrix
d[1,2]
source('~/Dropbox/work/teaching/gwu/bayesian_methods_for_data_science/lectures/slides/Chap_3_The_R_Programming_Language/SimpleGraph.R')
d = data.frame( Integers=1:3 , NumberNames=c("one","two","three") )
d
d$NumberNames   # notice this is a factor
d[[2]]          # the second element contents
d[2]            # the second element with its name
d[,2]           # elements can be accessed as if it's a matrix
d[2,]           # elements can be accessed as if it's a matrix
TRUE | TRUE & FALSE  # conjunction has precedence over disjunction
!TRUE  # negation
TRUE & FALSE  # conjunction
TRUE | FALSE  # disjunction
TRUE | TRUE & FALSE  # conjunction has precedence over disjunction
( TRUE | TRUE ) & FALSE  #
TRUE | TRUE & FALSE  # conjunction has precedence over disjunction
x == y   # although mathematically TRUE, it's FALSE for limited precision
x = 0.5 - 0.3
y = 0.3 - 0.1
x == y
all.equal(x,y)  # equal up to precision of computer
x = 0.5 - 0.3
y = 0.4 - 0.1
x == y   # although mathematically TRUE, it's FALSE for limited precision
all.equal(x,y)
?isTRUE
c(1,2,3) * c(7,6,5)
c(1,2,3) * c(7,6,5)
2 * c(1,2,3)
1:5
2+3:6      # colon operator has precedence over addition
seq( from=0 , to=3 , by=0.5 )          # length not specified
x = c( "high" , "medium" , "low" , "high" , "medium" )
xf = factor( x )
xf
as.numeric(xfo)
MyList = list( "a"=1:3 , "b"=matrix(1:6,nrow=2) , "c"="Hello, world." )
MyList = list( "a"=1:3 , "b"=matrix(1:6,nrow=2) , "c"="Hello, world." )
MyList
d = data.frame( Integers=1:3 , NumberNames=c("one","two","three") )
d
d$NumberNames   # notice this is a factor
d[[2]]          # the second element contents
HGNdf = read.csv( "HGN.csv" )
HGNdf$Hair
asqplusb = function( a , b=1 ) {  # begin function definition
c = a^2 + b
return( c )
}
asqplusb( a=2 )  # b gets default value
asqplusb = function( a = 1 , b ) {  # begin function definition
c = a^2 + b
return( c )
}  # end of function definition
x = 2
x=2
x >- 2
x
x > - 2
x = 5
x > - 2
